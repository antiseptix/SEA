.TH "src/skeleton.c" 3 "Wed Feb 8 2017" "Version 0.1" "SHELL_HEIL_BOUROUIS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/skeleton.c \- Fichier permettant de lancer un MiniShell\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <sys/stat\&.h>\fP
.br
\fC#include <getopt\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/wait\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <liste_chaine\&.h>\fP
.br
\fC#include <arbr\&.h>\fP
.br
\fC#include <StringGoodies\&.h>\fP
.br
\fC#include <builtin\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCOPIE_FILENAME\fP   'copie\&.txt'"
.br
.ti -1c
.RI "#define \fBTRUE\fP   1"
.br
.ti -1c
.RI "#define \fBFALSE\fP   0"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBbool\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBfree_if_needed\fP (void *to_free)"
.br
.ti -1c
.RI "int \fBfileExists\fP (char *ptrFile)"
.br
.ti -1c
.RI "\fBarbre\fP \fBaddNode\fP (char c, \fBliste\fP l, \fBarbre\fP a)"
.br
.ti -1c
.RI "char * \fBgetEnvVar\fP (char *name, char **envp)"
.br
.ti -1c
.RI "char * \fBgetCommande\fP (char *cmd, char **envp)"
.br
.ti -1c
.RI "char * \fBread_line\fP (void)"
.br
.ti -1c
.RI "void \fBaskUntilTag\fP (char *tag, int fd)"
.br
.ti -1c
.RI "int \fBexecRedirectFromFile\fP (char *cmd, char **envp, char *fileName, int append)"
.br
.ti -1c
.RI "pid_t \fBexecRedirectToFile\fP (char *cmd, char **envp, char *fileName, int append)"
.br
.ti -1c
.RI "int \fBexec\fP (\fBT\fP l, char **envp)"
.br
.ti -1c
.RI "void \fBexecArbre2\fP (\fBarbre\fP a, char **envp, int worked, int executeNext)"
.br
.ti -1c
.RI "int \fBremoveFirstLine\fP (int fdHistorique)"
.br
.ti -1c
.RI "int \fBcheckhistory\fP (int fdHistorique)"
.br
.ti -1c
.RI "int \fBisBackground\fP (\fBarbre\fP curArbre)"
.br
.ti -1c
.RI "void \fBprintArbre\fP (\fBarbre\fP a)"
.br
.ti -1c
.RI "int \fBmain\fP (int argc, char **argv, char **envp)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Fichier permettant de lancer un MiniShell\&. 


.PP
\fBAuthor:\fP
.RS 4
Alexis Heil, Sabrina Bourouis 
.RE
.PP
\fBVersion:\fP
.RS 4
0\&.1 
.RE
.PP
\fBDate:\fP
.RS 4
09 fevrier 2017
.RE
.PP
Mini Shell de Sabrina Bourouis et Alexis Heil 
.SH "Function Documentation"
.PP 
.SS "\fBarbre\fP addNode (char c, \fBliste\fP l, \fBarbre\fP a)"
Fonction qui permet d'ajouter un noeud a l'arbre passe en parametre Noeud : Racine = c, Feuille gauche = l, Feuille droite = a 
.PP
\fBParameters:\fP
.RS 4
\fIchar\fP c caractere a ajoute a la racine 
.br
\fIliste\fP l liste chainee a ajoute en tant que feuille gauche 
.br
\fIarbre\fP a arbre auquel on va ajouter le noeud 
.RE
.PP
\fBReturns:\fP
.RS 4
arbre une reference vers la racine de l'arbre 
.RE
.PP

.SS "void askUntilTag (char * tag, int fd)"
Fonction qui va demander a l'utilisateur de saisir des donnees a inserer dans le fichier fd tant que la valeur tag n'a pas ete saisie
.PP
\fBParameters:\fP
.RS 4
\fIchar\fP * tag valeur que l'utilisateur doit saisir pour terminer la lecture 
.br
\fIint\fP fd descripteur du fichier dans lequel les donnees vont etre inseree 
.RE
.PP

.SS "int checkhistory (int fdHistorique)"
Fonction qui va supprimer la premiere ligne du fichier Historique s'il contient plus de NB_LINE_HISTORY
.PP
\fBParameters:\fP
.RS 4
\fIint\fP fdHistorique filedescripteur du fichier dont on verifie le nombre de ligne 
.RE
.PP
\fBReturns:\fP
.RS 4
int le filedescripteur du fichier dont on verifie le nombre de ligne 
.RE
.PP

.SS "int exec (\fBT\fP l, char ** envp)"
Fonction qui va executer la commande l
.PP
\fBParameters:\fP
.RS 4
\fIliste\fP l commande que l'utilisateur a saisi 
.br
\fIchar\fP ** envp tableau des variables d'environnement 
.RE
.PP
\fBReturns:\fP
.RS 4
int code retour de la commande a executer 
.RE
.PP

.SS "void execArbre2 (\fBarbre\fP a, char ** envp, int worked, int executeNext)"
Fonction qui va executer toutes les commandes stockees dans l'arbre a
.PP
\fBParameters:\fP
.RS 4
\fIarbre\fP a arbre a executer 
.br
\fIchar\fP ** envp tableau des variables d'environnement 
.br
\fIint\fP worked pour connaitre le code retour de la derniere commande executee 
.br
\fIint\fP executeNext pour savoir si la commande de la feuille gauche doit etre executee 
.RE
.PP
\fBReturns:\fP
.RS 4
int code retour de la commande a executer 
.RE
.PP

.SS "int execRedirectFromFile (char * cmd, char ** envp, char * fileName, int append)"
Fonction qui va recuperer le contenu d'un fichier et le passer en argument de la commande a executer
.PP
\fBParameters:\fP
.RS 4
\fIchar\fP * cmd commande que l'utilisateur a tape 
.br
\fIchar\fP ** envp tableau des variables d'environnement 
.br
\fIchar\fP * fileName nom du fichier dans lequel il faut recuperer les donnees 
.br
\fIint\fP append booleen qui permet de savoir s'il faut demander a l'utilisateur de saisir les donnees au clavier jusqu'Ã  un tag 
.RE
.PP
\fBReturns:\fP
.RS 4
int code retour de la commande a executer 
.RE
.PP

.SS "pid_t execRedirectToFile (char * cmd, char ** envp, char * fileName, int append)"
Fonction qui va rediriger l'affichage dands un fichier
.PP
\fBParameters:\fP
.RS 4
\fIchar\fP * cmd commande que l'utilisateur a tape 
.br
\fIchar\fP ** envp tableau des variables d'environnement 
.br
\fIchar\fP * fileName nom du fichier dans lequel on va ecrire les donnees 
.br
\fIint\fP append booleen qui permet de savoir si on ajoute ou on remplace le contenu 
.RE
.PP
\fBReturns:\fP
.RS 4
int code retour de la commande a executer 
.RE
.PP

.SS "int fileExists (char * ptrFile)"
Fonction qui verifie l'existence d'un fichier
.PP
\fBParameters:\fP
.RS 4
\fIchar*\fP ptrFile nom du fichier dont il faut tester l'existence 
.RE
.PP
\fBReturns:\fP
.RS 4
int 1 = le fichier existe, 0 = le fichier n'existe pas 
.RE
.PP

.SS "void free_if_needed (void * to_free)"
Procedure permettant de verifier si la variable doit etre liberee (check: ptr != NULL)
.PP
\fBParameters:\fP
.RS 4
\fIvoid*\fP to_free pointeur vers une adresse memoire allouee grace a malloc, realloc,\&.\&.\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
man 3 free 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.SS "char* getCommande (char * cmd, char ** envp)"
Fonction qui permet de recuperer le fichier contenant la commande a execute necessaire pour execve
.PP
\fBParameters:\fP
.RS 4
\fIchar\fP * cmd nom de la commande qu'il faut trouver 
.br
\fIchar\fP ** envp contient une entree pour chaque varaible d'environnement necessaire pour retrouver la commande Ex : Path=valueOfPAth 
.RE
.PP
\fBReturns:\fP
.RS 4
char* chemin vers la commande a executer 
.RE
.PP

.SS "char* getEnvVar (char * name, char ** envp)"
Fonction qui permet de recuperer les variables d'envirronnement dans envp
.PP
\fBParameters:\fP
.RS 4
\fIchar\fP * name nom de la variable d'environnement dont on souhaite recuperer la valeur 
.br
\fIchar\fP ** envp contient une entree pour chaque varaible d'environnement Ex : Path=valueOfPAth 
.RE
.PP
\fBReturns:\fP
.RS 4
char* la valeur de la variable d'environnement 
.RE
.PP

.SS "int isBackground (\fBarbre\fP curArbre)"
Fonction qui verifie s'il y a un caractere & seul dans l'arbre, ce qui signifie que le programme doit etre executer en background
.PP
\fBParameters:\fP
.RS 4
\fIarbre\fP curArbre arbre dans lequel on verifie s'il y a & 
.RE
.PP
\fBReturns:\fP
.RS 4
int 0 si & pas present 1 si present 
.RE
.PP

.SS "void printArbre (\fBarbre\fP a)"
procedure qui permet d'afficer un arbre, utile pour le debogage 
.PP
\fBParameters:\fP
.RS 4
\fIarbre\fP a arbre a afficher 
.RE
.PP

.SS "char* read_line (void)"
Fonction qui permet de lire une ligne saisi au clavier 
.PP
\fBReturns:\fP
.RS 4
char* la ligne saisie au clavier 
.RE
.PP

.SS "int removeFirstLine (int fdHistorique)"
Fonction qui va supprimer la premiere ligne d'un fichier
.PP
\fBParameters:\fP
.RS 4
\fIint\fP fdHistorique filedescripteur du fichier dont on doit supprimer la premiere ligne 
.RE
.PP
\fBReturns:\fP
.RS 4
int le filedescripteur du fichier dont on a supprime la premiere ligne 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for SHELL_HEIL_BOUROUIS from the source code\&.
